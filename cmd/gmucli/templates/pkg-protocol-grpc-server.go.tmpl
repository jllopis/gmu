package grpc

import (
	"context"
	"net"
	"os"
	"os/signal"

	"{{ .PackageName }}/pkg/logger"
	"{{ .PackageName }}/pkg/protocol/grpc/middleware"

	grpc_middleware "github.com/grpc-ecosystem/go-grpc-middleware"
	"github.com/soheilhy/cmux"
	"google.golang.org/grpc"
	"google.golang.org/grpc/reflection"
)

type GrpcServer struct {
	listener             net.Listener
	grpcSrv              *grpc.Server
	maxConcurrentStreams int
	grpcReflection       bool
	// Interceptors
	unaryInter               []grpc.UnaryServerInterceptor
	streamInter              []grpc.StreamServerInterceptor
	interceptorInitializers  []InterceptorInitializer
	grpcServicesRegistrators []ServiceRegistrator
}

type (
	ServiceRegistrator func()
)

// InterceptorInitializer defines an interface with the methods that
// should be implemented to setup an interceptor.
//
// InterceptorInitializers will be added to GrpcServer.InterceptorInitializers slice
// and when the server is created, this array will be traversed and for every item the
// method Init(*GrpcServer) will be called.
//
// This will register the intercepto into the GrpcSrv.
type InterceptorInitializer interface {
	Init(*GrpcServer)
}

func New(listen net.Listener) *GrpcServer {
	if listen == nil {
		logger.Log.Fatal("grpc.Serve got a nil listener")
	}

	return &GrpcServer{
		listener: listen,
	}
}

// Serve runs gRPC service
// TODO: passar en conter de {{ .ApiVersion }}.EchoServiceServer un array []ServiceRegistrator (y en rest ServiceGwRegistrator) per permetre mÃ©s d'un servei
func (g *GrpcServer) Serve(ctx context.Context) {
	grpcOpts := []grpc.ServerOption{
		grpc_middleware.WithUnaryServerChain(g.unaryInter...),
		grpc_middleware.WithStreamServerChain(g.streamInter...),
	}
	if g.maxConcurrentStreams > 0 {
		grpcOpts = append(grpcOpts, grpc.MaxConcurrentStreams(uint32(g.maxConcurrentStreams)))
	}

	// register service
	g.grpcSrv = grpc.NewServer(
		grpcOpts...,
	)
	g.initializeInterceptors()

	g.registerGrpcServices()

	if g.grpcReflection {
		reflection.Register(g.grpcSrv)
	}

	// graceful shutdown
	c := make(chan os.Signal, 1)
	signal.Notify(c, os.Interrupt)
	go func() {
		for range c {
			// sig is a ^C, handle it
			logger.Log.Warn("shutting down gRPC server...")
			g.grpcSrv.GracefulStop()
			<-ctx.Done()
		}
	}()

	// start gRPC server
	logger.Log.Info("starting gRPC server on " + g.listener.Addr().String())
	if err := g.grpcSrv.Serve(g.listener); err != cmux.ErrListenerClosed {
		panic(err)
	}
}


func (g *GrpcServer) Register(sr ServiceRegistrator) {
	g.grpcServicesRegistrators = append(g.grpcServicesRegistrators, sr)
}

// UseUnaryInterceptor adds a unary interceptor to the RPC server
func (g *GrpcServer) UseUnaryInterceptor(inter grpc.UnaryServerInterceptor) {
	g.unaryInter = append(g.unaryInter, inter)
}

// UseStreamInterceptor adds a stream interceptor to the RPC server
func (g *GrpcServer) UseStreamInterceptor(inter grpc.StreamServerInterceptor) {
	g.streamInter = append(g.streamInter, inter)
}

func (g *GrpcServer) RegisterInterceptorInitializer(i InterceptorInitializer) {
	g.interceptorInitializers = append(g.interceptorInitializers, i)
}

func (g *GrpcServer) initializeInterceptors() {
	for _, i := range g.interceptorInitializers {
		i.Init(g)
	}
}

func (g *GrpcServer) registerGrpcServices() {
	for _, s := range g.grpcServicesRegistrators {
		s()
	}
}

func (g *GrpcServer) SetMaxConcurrentStreams(n int) *GrpcServer {
	g.maxConcurrentStreams = n
	return g
}

func (g *GrpcServer) UseReflection() *GrpcServer {
	g.grpcReflection = true
	return g
}

func (g *GrpcServer) GetGrpcServer() *grpc.Server {
	return g.grpcSrv
}

func (g *GrpcServer) UseLogging() *GrpcServer {
	g.unaryInter = append([]grpc.UnaryServerInterceptor{middleware.AddUnaryLogging(logger.Log)}, g.unaryInter...)
	g.streamInter = append([]grpc.StreamServerInterceptor{middleware.AddStreamLogging(logger.Log)}, g.streamInter...)
	return g
}
