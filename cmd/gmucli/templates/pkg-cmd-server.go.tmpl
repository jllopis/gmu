package cmd

import (
	"context"
	"fmt"
	"net"

	"github.com/soheilhy/cmux"
	google_grpc "google.golang.org/grpc"

	api{{ .ApiVersion | ToUpper }} "{{ .PackageName }}/pkg/api/{{ .ApiVersion }}"
	"{{ .PackageName }}/pkg/logger"
	{{ if .WithDb -}}"{{ .PackageName }}/pkg/store/gopg"{{ end }}
	"{{ .PackageName }}/pkg/protocol/grpc"
	"{{ .PackageName }}/pkg/protocol/grpc/middleware"
	"{{ .PackageName }}/pkg/protocol/rest"
	service{{ .ApiVersion | ToUpper }} "{{ .PackageName }}/pkg/service/{{ .ApiVersion }}"

	"github.com/jllopis/getconf"
)

// Config is configuration for Server
type Config struct {
	// Service default port shared by protocols gRPC, http
	DefaultPort string `getconf:"port, default: 9000, info: port to bind services"`
	// Log parameters section
	// LogLevel is global log level: Debug(-1), Info(0), Warn(1), Error(2), DPanic(3), Panic(4), Fatal(5)
	LogLevel int `getconf:"log-level, default: 0, info: Global log level"`
	// LogTimeFormat is print time format for logger e.g. 2006-01-02T15:04:05Z07:00
	LogTimeFormat string `getconf:"log-time-format, info: Print time format for logger e.g. 2006-01-02T15:04:05Z07:00"`
	// set max concurrent streams served by gRPC server
	GrpcMaxConcurrentStreams int `getconf:"grpc-max-concurrent-streams, default: 250, info: grpc server option MaxConcurrentStreams"`
	// Expose Prometheus metrics
	UsePrometheus bool `getconf:"use-prometheus, default: true, info: expose prometheus metrics"`
	// endpoint for Prometheus metrics
	PrometheusEndpoint string `getconf:"prometheus-endpoint, default: /metrics, info: endpoint to serve prometheus metrics. Only available if UsePrometheus()"`
	// if mode is dev, log everything
	Mode string `getconf:"mode, default: dev, info: set the environment (dev staging or prod)"`
	{{ if .WithDb -}}
	Store struct {
		Host    string `getconf:"host, default: db.acb.info, info: store server address"`
		Port    string `getconf:"port, default: 5432, info: store server port"`
		Name    string `getconf:"name, default: {{ .ProjectName }}db, info: store database name"`
		User    string `getconf:"user, default: {{ .ProjectName }}adm, info: store user to connect to db"`
		Pass    string `getconf:"pass, default: 00000000, info: store user password"`
	}
	{{ end }}
}

// RunServer runs gRPC server and HTTP gateway
func RunServer() error {
	// Load config before doing anything else so we can quit early if error
	getconf.Load(&getconf.LoaderOptions{
		ConfigStruct: &Config{},
		EnvPrefix:    "ECH",
	})

	ctx := context.Background()

	if getconf.GetInt("port") == 0 {
		return fmt.Errorf("invalid TCP port for server: '%s'", getconf.GetString("port"))
	}

	// initialize logger
	if err := logger.Init(getconf.GetInt("log-level"), getconf.GetString("log-time-format")); err != nil {
		return fmt.Errorf("failed to initialize logger: %v", err)
	}

	{{ if .WithDb -}}
	// Start store connections
	// Enable query logger if mode is "dev"
	enableQueryLogger := false
	mode := getconf.GetString("mode")
	if mode == "dev" {
			enableQueryLogger = true
	}

	dbstore, err := gopg.New()
	if err != nil {
			return fmt.Errorf("Could not create store Manager error: %s", err.Error())
	}

	err = dbstore.Dial(map[string]interface{}{
			"host":              getconf.GetString("store::host"),
			"port":              getconf.GetInt("store::port"),
			"user":              getconf.GetString("store::user"),
			"password":          getconf.GetString("store::pass"),
			"dbname":            getconf.GetString("store::name"),
			"sslmode":           "disable",
			"enableQueryLogger": enableQueryLogger,
	})
	if err != nil {
			return fmt.Errorf("Could not connect to store error: %s", err.Error())
	}
	{{- end }}
	// create the tcp muxer
	mux, err := newCmux(nil, getconf.GetString("port"))
	if err != nil {
		logger.Log.Fatal("cant create tcp listener for CMux, error:" + err.Error())
	}
	// Match connections in order:
	// First grpc, and otherwise HTTP.
	// grpcListener := mux.Match(cmux.HTTP2HeaderFieldPrefix("content-type", "application/grpc"))
	grpcListener := mux.MatchWithWriters(cmux.HTTP2MatchHeaderFieldSendSettings("content-type", "application/grpc"))
	// Otherwise, we match it againts HTTP1 methods. If matched,
	// it is sent through the "httpl" listener.
	// httpListener := mux.Match(cmux.HTTP1Fast())
	// Any significa que no hay coincidencia previa
	httpListener := mux.Match(cmux.Any())

	logger.Log.Info("service started on port " + getconf.GetString("port"))

	// run gRPC gateway
	grpcSrv := grpc.New(grpcListener).
		SetMaxConcurrentStreams(getconf.GetInt("grpc-max-concurrent-streams")).
		UseReflection().
		UseLogging(&middleware.LoggingConfig{Logger: logger.Log}){{- if .WithDb }}.
		UseStore(dbstore){{ end }}
	// Register gRPC services
	serviceRegistrator := func() {
		api{{ .ApiVersion | ToUpper }}.Register{{.ServiceName}}ServiceServer(grpcSrv.GetGrpcServer(), service{{ .ApiVersion | ToUpper }}.New{{.ServiceName}}ServiceServer())
	}
	grpcSrv.Register(serviceRegistrator)

	go grpcSrv.Serve(ctx)

	// run HTTP gateway
	restSrv := rest.New(httpListener, nil).WithCORS().LogRequests()
	restSrv.Register(func(){
		api{{ .ApiVersion | ToUpper }}.Register{{.ServiceName}}ServiceHandlerFromEndpoint(context.Background(), restSrv.GetRuntimeMux(),
			"localhost:"+getconf.GetString("port"),
			[]google_grpc.DialOption{google_grpc.WithInsecure()})
	})

	if getconf.GetBool("use-prometheus") {
		grpcSrv.UsePrometheus(&middleware.PrometheusInterceptorConfig{
			HttpMux:             restSrv.GetHttpMux(),
			Endpoint:            getconf.GetString("prometheus-endpoint"),
			EnableTimeHistogram: true,
		})
	}

	go restSrv.Serve(ctx)

	return mux.Serve()
}

func newCmux(l net.Listener, port string) (cmux.CMux, error) {
	var err error
	if l == nil {
		// Create the main listener.
		l, err = net.Listen("tcp", ":"+port)
		if err != nil {
			return nil, err
		}
	}
	return cmux.New(l), nil
}