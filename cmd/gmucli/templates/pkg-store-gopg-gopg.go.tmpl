package gopg

import (
        "crypto/tls"
        "fmt"
        "strconv"
        "time"

		"{{ .PackageName }}/pkg/logger"
		"{{ .PackageName }}/pkg/store"

		GOPG "github.com/go-pg/pg"
		"go.uber.org/zap"
)

// GopgStore is a Storer implementation over PostgresSQL
type GopgStore struct {
        Pool *GOPG.DB
        Stat int
}

var _ store.Storer = (*GopgStore)(nil)

// New is a default Storer implementation based upon PostgresSQL
func New() (*GopgStore, error) {
        return &GopgStore{}, nil
}

// Dial perform the connection to the underlying database server
func (d *GopgStore) Dial(options store.Options) error {
        tlsConfig := &tls.Config{
                InsecureSkipVerify: false,
        }
        sslMode := true
        if v, ok := options["sslMode"]; !ok || v == "disable" {
                tlsConfig = nil
                sslMode = false
        }
        if v, ok := options["maxConns"]; !ok || v.(int) == 0 {
                options["maxConns"] = 20
        }
        // In minutes, time after which client closes idle connections
        if v, ok := options["idleTimeoutMin"]; !ok || v.(int) == 0 {
                options["idleTimeoutMin"] = 15
        }
        if v, ok := options["host"]; !ok || v.(string) == "" {
                options["host"] = "localhost"
        }
        if v, ok := options["port"]; !ok || v.(int) == 0 {
                options["port"] = 5432
        }

        addr := options["host"].(string) + ":" + strconv.Itoa(options["port"].(int))
        pgOptions := &GOPG.Options{
                TLSConfig:   tlsConfig,
                PoolSize:    options["maxConns"].(int),
                IdleTimeout: time.Duration(options["idleTimeoutMin"].(int)) * time.Minute,
                Addr:        addr,
                User:        options["user"].(string),
                Password:    options["password"].(string),
                Database:    options["dbname"].(string),
        }

        dsn := fmt.Sprintf("user=%s dbname=%s sslmode=%t address=%s", pgOptions.User, pgOptions.Database, sslMode, pgOptions.Addr)
        logger.Log.Info("connecting to postgresql", zap.String("dsn", dsn))
        d.Pool = GOPG.Connect(pgOptions)
		if err := d.Ping(); err != nil {
			return err
		}
        d.Stat = store.CONNECTED

        s := d.Pool.Options()

        logger.Log.Info("created GOPG pool store", zap.Int("poolSize", s.PoolSize))

        if options["enableQueryLogger"] == true {
                // EnableQueryLogger will log all queries make to the database
                d.Pool.AddQueryHook(&QH{})
        }

        return nil
}

type QH struct{}
func (q *QH) BeforeQuery(event *GOPG.QueryEvent) { return }
func (q *QH) AfterQuery(event *GOPG.QueryEvent) {
        query, err := event.FormattedQuery()
        if err != nil {
                logger.Log.Error("error formatting query", zap.String("error", err.Error()))
                return
        }

        // logger.Log.Info("[GO-PG]", zap.Duration("duration", time.Since(event.StartTime)), zap.String("q", query))
        logger.Log.Info("[GO-PG", zap.String("q", query))
        logger.Log.Info("[GO-PG]", zap.Reflect("event", event))
}

// Status return the current status of the underlying database
func (d *GopgStore) Status() (int, string) {
        return d.Stat, store.StatusStr[d.Stat]
}


// Ping verifica que la conexión esté abierta
func (d *GopgStore) Ping() error {
	_, err := d.Pool.Exec("SELECT 1")
	if err != nil {
		return err
	}
	
	return nil
}

// Close effectively close de database connection
func (d *GopgStore) Close() error {
        logger.Log.Info("GoPg store CLOSING")
        err := d.Pool.Close()
        if err != nil {
                logger.Log.Info("Error closing DB connection", zap.String("error", err.Error()))
        }
        d.Stat = store.DISCONNECTED
        return nil
}